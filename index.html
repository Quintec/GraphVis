<!DOCTYPE html>
<html lang="">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/purecss@2.0.6/build/pure-min.css" integrity="sha384-Uu6IeWbM+gzNVXJcM9XV3SohHtmWE+3VGi496jvgX1jyvDTXfdK+rfZc8C1Aehk5" crossorigin="anonymous">
  <title>GraphVis</title>
  <style>
    body {
      padding: 0;
      margin: 0;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.min.js"></script>
</head>

<body>
  <div id="settings">
    
  </div>
  <div id="wrap"></div>

  <script type="text/javascript">
    let HEIGHT = 500;
    let WIDTH = 500;

    let SPEED = 0.02;
    let TENSION = 30;
    let SIZE = 30;

    class Node {
      constructor(name) {
        this.name = name;
        this.x = Math.random() * WIDTH;
        this.y = Math.random() * HEIGHT;
        this.vx = 0;
        this.vy = 0;
      }
    }

    class Graph {
      constructor() {
        this.adj = {};
        this.nodes = [];
      }

      addEdge(from, to, len) {
        if (!Object.keys(this.adj).includes(from)) {
          this.adj[from] = {};
          this.nodes.push(new Node(from));
        }

        if (!Object.keys(this.adj).includes(to)) {
          this.adj[to] = {};
          this.nodes.push(new Node(to));
        }

        this.adj[from][to] = len;
        this.adj[to][from] = len;
      }

      step() {
        for (let node of this.nodes) {
          node.x += node.vx;
          node.y += node.vy;

          node.vx = 0;
          node.vy = 0;
        }
      }

      //everything has a charge and repels
      applyCharges() {
        let vertices = Object.keys(this.adj);
        for (var i = 0; i < vertices.length; i++) {
          for (var j = i + 1; j < vertices.length; j++) {
            let na = this.nodes[i];
            let nb = this.nodes[j];
            let dx = na.x - nb.x;
            let dy = na.y - nb.y;

            na.vx += SPEED * 2 / (dx + 1);
            nb.vx -= SPEED * 2 / (dx + 1);
            na.vy += SPEED * 2 / (dy + 1);
            nb.vy -= SPEED * 2 / (dy + 1);
          }
        }
      }

      //connect nodes with length of rope
      applyRopes() {
        let vertices = Object.keys(this.adj);
        for (var i = 0; i < vertices.length; i++) {
          for (var j = i + 1; j < vertices.length; j++) {
            let na = this.nodes[i];
            let nb = this.nodes[j];
            if (Object.keys(this.adj[na.name]).includes(nb.name)) {
              let dx = na.x - nb.x;
              let dy = na.y - nb.y;
              let dist = Math.sqrt(dx * dx + dy * dy)
              let slack = dist - this.adj[na.name][nb.name] * TENSION;
              if (slack > 0) {
                na.vx -= SPEED * slack / dist * dx;
                nb.vx += SPEED * slack / dist * dx;
                na.vy -= SPEED * slack / dist * dy;
                nb.vy += SPEED * slack / dist * dy;
              }
            }
          }
        }
      }


    }  

    var g = new Graph();
    g.addEdge('a', 'b', 2);
    g.addEdge('a', 'c', 5);

    function setup() {
      let can = createCanvas(WIDTH, HEIGHT);
      can.parent('wrap');
      frameRate(30);
    }

    function draw() {
      background(220);

      g.applyRopes();
      g.applyCharges();
      g.step();

      for (let node of g.nodes) {
        circle(node.x, node.y, SIZE);
        textAlign(CENTER, CENTER);
        text(node.name, node.x, node.y);
      }
    }
  </script>
</body>

</html>